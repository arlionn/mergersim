{smcl}
{com}{sf}{ul off}{txt}{.-}
      name:  {res}<unnamed>
       {txt}log:  {res}C:\Users\n13017\Documents\Programming\mergersim\trunk\calibrated_elasticities.smcl
  {txt}log type:  {res}smcl
 {txt}opened on:  {res}15 Sep 2014, 16:43:59

{com}. do "C:\Users\n13017\Documents\Programming\mergersim\trunk\calibrated_elasticities.do"
{txt}
{com}. version 11.2
{txt}
{com}. clear all
{txt}
{com}. discard
{txt}
{com}. compile
{txt}
{com}. /***************************
> 
> MERGER SIMULATION PACKAGE FOR STATA
> Jonas Björnerstedt and Frank Verboven
> 
> $Id: mergersim.mata 223 2014-08-16 14:05:06Z d3687-mb $
> 
> ***************************/
. version 11.2
{txt}
{com}. 
. mata:
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}: 
: class VariableClass {c -(}
>         string scalar marketvar // from xtset, set in init. Used for byable.
> public:
>         // Variables and functions for byable
>         real scalar periods
>         void setperiods()
>         void period()
>         void  createvariable(), getvariable(), check_variable()
> protected:
>         real matrix groupindex(), group_matrix()
>         string scalar periodvar 
> 
> private:
>         real matrix index
>         real matrix period
> {c )-}

: 
: class Demand extends VariableClass {c -(}
>         string estimate // Name of vector of estimates
>         string variance
>         real scalar valueshares // To indicate that shares are in value terms rather than quantity. 
> 
>         virtual real matrix share_jacobian()
>         virtual void get_data()
>         virtual void init()
>         virtual void elasticities()
>         virtual void parameters()
>         virtual real scalar valueshares(), consumerSurplus()
>         virtual real matrix demand(), quantity() // Transform to and from shares
> private:
>         virtual real matrix shares(), group_shares()
>         void new() 
> {c )-}

: 
: class LogitDemand extends Demand {c -(}
>         real scalar alpha
>         real scalar sigma1
>         real scalar sigma2
>         real matrix sigma
>         real scalar ces
>         real scalar nests
>         string nest1
>         string nest2
>         string delta
>         string marketsize
>         string estimate // Name of vector of estimates
>         string variance
> 
>         real scalar valueshares // To indicate that shares are in value terms rather than quantity. 
>         // Dataset variables, common to both pre-merger and post-merger
>         real matrix d // Utility
>         real matrix mk // Marketsize
> private:        
>         real matrix G // Group membership, each column a group with 1 if member
>         real matrix GH // Subgroup membership
>         real matrix GG // Group membership matrix
>         real matrix GHGH // Subgroup membership matrix
>         real matrix GN // Binary matrix of subgroup membership in group
> public:
>         virtual real scalar valueshares(), consumerSurplus()
>         virtual void elasticities()
>         virtual void parameters()
>         virtual real matrix demand(), quantity() // Transform to and from shares
>         virtual real matrix shares(), group_shares()
>         virtual real matrix share_jacobian()
>         virtual void get_data()
>         virtual void init()
> private:
>         void new() 
> {c )-}

: 
: class CesLogitDemand extends LogitDemand {c -(}
>         virtual real matrix demand(), quantity()  
>         virtual real matrix shares()
>         virtual real scalar consumerSurplus()
>         virtual real matrix share_jacobian()
> {c )-}

: 
: // *******************************************
: 
: void Demand::new()
> {c -(}
> {c )-}

: 
: void LogitDemand::new()
> {c -(}
>         ces = 0
>         nests = 0
> {c )-}

: 
: /********************************************************************************/
: // LogitDemand class
: 
: real scalar LogitDemand::valueshares()
> {c -(}
>         return(valueshares)
> {c )-}

: 
: // Pass revenues to function for valueshares, otherwise quantity
: real matrix LogitDemand::demand(real matrix Q, real matrix P)
> {c -(}
>         real matrix S
>         S = Q :/ mk     
>         return( S )
> {c )-}
{txt}note: argument P unused

{com}: 
: // Pass revenues to function for valueshares, otherwise quantity
: real matrix CesLogitDemand::demand(real matrix Q, real matrix P)
> {c -(}
>         real matrix S
>         S = Q :* P :/ mk 
>         return( S )
> {c )-}

: 
: real matrix LogitDemand::quantity(real matrix S, real matrix P)
> {c -(}
>         real matrix Q
>         Q = S :* mk
>         return( Q )
> {c )-}
{txt}note: argument P unused

{com}: 
: real matrix CesLogitDemand::quantity(real matrix S, real matrix P)
> {c -(}
>         real matrix Q
>         Q = S :* mk :/ P
>         return( Q )
> {c )-}

: 
: real matrix LogitDemand::share_jacobian(real matrix S, real matrix P)
> {c -(}
>         real matrix Sg
>         real matrix Sgh
>         real matrix gr_effect
>         real matrix own_effect
>         real matrix other_effect
>         real matrix DD
> 
>         other_effect =  - S*S' 
>         
>         if(nests == 0) {c -(}        
>                 own_effect = diag(S)
>                 return( - alpha*( own_effect + other_effect )  )
>         {c )-} else {c -(}
>                 Sg = GG*S
>                 own_effect = 1/(1 - sigma[1])*diag(S)
>                 if(nests == 2) {c -(}
>                         gr_effect = - sigma[2]/(1 - sigma[2])*GG :* ((S :/ Sg)*S')
>                         Sgh = GHGH*S
>                         gr_effect = gr_effect - (1/(1 - sigma[1]) - 1/(1 - sigma[2]))*GHGH :* ((S :/ Sgh)*S')   
>                 {c )-} else {c -(}
>                         gr_effect = - sigma[1]/(1 - sigma[1])*GG :* ((S :/ Sg)*S')
>                 {c )-} 
>                 return( - alpha*( own_effect + gr_effect + other_effect )  )
>         {c )-}
> {c )-}
{txt}note: argument P unused
note: variable DD unused

{com}: 
: // note that the premultiplied diagonal matrix with prices in ces cancels out in the FOC
: real matrix CesLogitDemand::share_jacobian(real matrix S, real matrix P)
> {c -(}
>         return( ( super.share_jacobian( S, P) :- diag(S) )  * diag(1:/P) )
> {c )-}

: 
: real matrix LogitDemand::shares(real matrix P)
> {c -(}
>         real matrix s
>         real delta
>         real i
> 
>         real ev
>         real matrix ig
>         real matrix igs
>         delta = d - alpha*P // d is delta without price effect
>         if(nests == 2) {c -(}
>                 real matrix igh
>                 real matrix ighs
>                 real matrix evv
>                 ev=exp(delta :/ (1-sigma[1]))
>                 ighs = (GH*ev)
>                 igh = GH'*ighs
>                 evv = ighs :^ ((1-sigma[1])/(1-sigma[2]))
>                 igs = (GN*evv)  
>                 ig = G'*igs
>                 i = sum(igs :^(1-sigma[2]))
> 
>                 s = ev :* (igh :^ ((sigma[2]-sigma[1])/(1-sigma[2])) ) :* (ig :^ (-sigma[2])) / (1+i)
>         {c )-} else if(nests == 1) {c -(}
>                 ev=exp(delta :/ (1-sigma[1]))
>                 igs = (G*ev) 
>                 ig = G'*igs
>                 i = sum(igs :^(1-sigma[1]))
>                 s = ev :* (ig :^ (-sigma[1])) / (1+i)
>         {c )-} else {c -(}
>                 ev=exp(delta )
>                 i = sum(ev)
>                 s = ev / (1+i)
>         {c )-} 
>         return(s)
> {c )-}

: 
: real scalar LogitDemand::consumerSurplus(real matrix P)
> {c -(}
>         real matrix s
>         real delta
>         real i
> 
>         real ev
>         real matrix ig
>         real matrix igs
>         delta = d - alpha*P // d is delta without price effect
>         if(nests == 2) {c -(}
>                 real matrix ighs
>                 real matrix evv
>                 ev=exp(delta :/ (1-sigma[1]))
>                 ighs = (GH*ev)
>                 evv = ighs :^ ((1-sigma[1])/(1-sigma[2]))
>                 igs = (GN*evv)  
>                 i = sum(igs :^(1-sigma[2]))
> 
>         {c )-} else if(nests == 1) {c -(}
>                 ev=exp(delta :/ (1-sigma[1]))
>                 igs = (G*ev) 
>                 i = sum(igs :^(1-sigma[1]))
>         {c )-} else {c -(}
>                 ev=exp(delta )
>                 i = sum(ev)
>         {c )-} 
>         return(log(1 + i)/alpha * mk[1])
> {c )-}
{txt}note: variable s unused
note: variable ig unused

{com}: 
: real matrix CesLogitDemand::shares(real matrix P)
> {c -(}
>                 return(super.shares(log(P)))
> {c )-}

: 
: real scalar CesLogitDemand::consumerSurplus(real matrix P)
> {c -(}
>                 return(super.consumerSurplus(log(P)))
> {c )-}

: 
: void LogitDemand::get_data(string scalar touse)
> {c -(}
>         real matrix e
>         real matrix groupvars
>         real matrix g
>         real matrix g2
>         st_view(d, ., delta, touse)
>         st_view(mk, ., marketsize, touse)
>         e = st_matrix(estimate)
>         if( alpha == .) {c -(}
>                 alpha = - e[1] // Note negation of alpha
>                 if( nests == 1 ) {c -(}
>                         sigma = (sigma1)
>                 {c )-} else if( nests == 2 ) {c -(}
>                         sigma = (sigma1, sigma2)
>                 {c )-} 
>         {c )-} else 
>                 assert(e != .)
>         if( nests > 0 ) {c -(}
>                 sigma = e[|2\.|]
>                 real matrix gr
>                 st_view(groupvars, ., (nest1, nest2), touse)
>                 gr = groupindex(groupvars)
>                 g = gr[.,1]
>                 G = group_matrix(g)
>                 GG = G'*G
> 
>                 if(nests == 2) {c -(}
>                         g2 = gr[.,2]
>                         GH = group_matrix(g2)
>                         GHGH = GH'*GH
>                         GN = (G*GH') :> 0
>                 {c )-}
>         {c )-}       
> {c )-}
{txt}note: variable groupvars may be used before set

{com}: 
: void LogitDemand::init()
> {c -(}
>         check_variable(delta, "delta")  
>         if(nests >= 1) {c -(}
>                 check_variable(nest1, "nest1")  
>         {c )-}
>         if(nests == 2) {c -(}
>                 check_variable(nest2, "nest2")  
>         {c )-}
>         check_variable(marketsize, "marketsize")
> {c )-}

: 
: void LogitDemand::parameters()
> {c -(}
>         st_global("r(delta)", delta)
>         st_global("r(nest1)", nest1)
>         st_global("r(nest2)", nest2)
>         st_numscalar("r(nestlevel)", nests)
>         st_global("r(marketsize)", marketsize)
>         st_numscalar("r(ces)", ces)
>         st_numscalar("r(valueshares)", valueshares)
>         st_numscalar("r(alpha)", -alpha)
>         st_numscalar("r(sigma1)", sigma1)
>         st_numscalar("r(sigma2)", sigma2)
> {c )-}

: 
: end
{txt}{hline}

{com}. 
{txt}end of do-file

{com}. /***************************
> 
> MERGER SIMULATION PACKAGE FOR STATA
> Jonas Björnerstedt and Frank Verboven
> 
> $Id: pcaids_demand.mata 193 2013-04-18 17:11:56Z d3687-mb $
> 
> ***************************/
. version 11.2
{txt}
{com}. 
. mata:
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}: 
: class PcaidsDemand extends Demand {c -(}
>         real scalar e
>         real scalar e11
> 
>         real matrix a
>         real matrix b
>         real scalar mk
> 
>         string price
>         string quantity
>         
>         string estimate // Name of vector of estimates
>         string variance
> 
>         real scalar valueshares // To indicate that shares are in value terms rather than quantity. 
> public:
>         virtual void elasticities()
>         virtual real matrix demand(), quantity() // Transform to and from shares
>         virtual real matrix shares(), group_shares()
>         virtual real matrix share_jacobian()
>         virtual void get_data()
>         virtual void init(), get_shares()
>         virtual void parameters()
> private:
>         void new() 
>         real matrix elas()
> {c )-}

: 
: // *******************************************
: 
: 
: void PcaidsDemand::new()
> {c -(}
> {c )-}

: 
: /********************************************************************************/
: // PcaidsDemand class
: 
: // Pass revenues to function for valueshares, otherwise quantity
: real matrix PcaidsDemand::demand(real matrix Q, real matrix P)
> {c -(}
>         real matrix S
>         real matrix D
>         D = P :* Q
>         S = Q :/ mk
>         return( S )
> {c )-}
{txt}note: variable D set but not used

{com}: 
: real matrix PcaidsDemand::quantity(real matrix S)
> {c -(}
>         real matrix Q
>         Q = S :* mk
>         return( Q )
> {c )-}

: 
: real matrix PcaidsDemand::shares(real matrix p)
> {c -(}
>         return( a + b*log(p) )
> {c )-}

: 
: real matrix PcaidsDemand::elas(real matrix s)
> {c -(}
>         real scalar len
>         len = rows(b)
>         return( b*diag(1:/s) + J(len, len, 1)*diag(s)*(1+e) - I(len) )
> {c )-}

: 
: real matrix PcaidsDemand::share_jacobian(real matrix s, real matrix p)
> {c -(}
>         return(elas(s)*diag(s:/p))
> {c )-}

: 
: void PcaidsDemand::get_data(string scalar touse)
> {c -(}
>         real matrix p
>         real matrix q
>         real matrix s
>         st_view(p, ., price, touse)
>         st_view(q, ., quantity, touse)
>         mk = sum(q) // Set marketsize
>         
>         s = demand(q, p)
>         real scalar b11
>         real matrix bii, t
>         b11 = s[1]*(e11 + 1 -s[1]*(e + 1) ) 
>         bii = (s :* (1 :- s)) /(s[1]*(1 - s[1]) ) * b11
>         t = -s *( 1 :/ (1 :- s) )' + diag(s :/(1 :- s) )
>         
>         b =  t * diag(bii) + diag(bii)
>         a = s - b*log(p)        
> {c )-}
{txt}note: variable p may be used before set
note: variable q may be used before set

{com}: 
: void PcaidsDemand::init()
> {c -(}
>         check_variable(price, "price")  
>         check_variable(quantity, "quantity")
> {c )-}

: 
: void PcaidsDemand::parameters()
> {c -(}
>         st_global("r(price)", price)
>         st_global("r(quantity)", quantity)
>         st_numscalar("r(e)", e)
>         st_numscalar("r(e11)", e11)
> {c )-}

: 
: end
{txt}{hline}

{com}. 
{txt}end of do-file

{com}. /***************************
> 
> MERGER SIMULATION PACKAGE FOR STATA
> Jonas Björnerstedt and Frank Verboven
> 
> $Id: mergersim_equilibrium.mata 224 2014-08-16 16:36:47Z d3687-mb $
> 
> ***************************/
. version 11.2
{txt}
{com}. 
. mata:
{txt}{hline 49} mata (type {cmd:end} to exit) {hline}
{com}: 
: class Merger extends VariableClass {c -(}
>         class Market matrix m
>         string scalar bootresults
> private:
>         void new()
> 
> public:
>         void init()
>         void equilibrium(), costestimate(), demand(), consumerSurplus()
> {c )-}

: 
: class SolverParam {c -(}
>         real scalar method
>         real scalar maxit
>         real scalar sensitivity
>         real scalar firstit //  Number of fixed_point iterations before Newton method in combined.
>         real scalar dampen
>         real scalar dampenIfNecessary
>         real scalar prediction  
>         real scalar h_epsilon
> 
>         void new(), init()
> {c )-}

: 
: class Solver extends VariableClass {c -(}
>         static class SolverParam scalar param
> {c )-}

: 
: class Market extends Solver {c -(}
>         real scalar conduct
>         // Varnames
>         string firm
>         string price
>         string quantity 
>         string costs
>         string initprice
>         string ownershipmatrix
> 
>         // Dataset variables
>         real matrix q // shares
>         real matrix p // prices
>         real matrix p0 // Initial prices
>         real matrix c // Costs
> 
>         real matrix s // shares
>         real matrix R // ownership tranformation matrix with conduct
> public:
>         void find_costs(), get_demand()
>         real matrix equilibrium()
> 
>         void get_data()
>         void init(), parameters()
> private:
>         real matrix foc(), margins()
>         real matrix fixed_point(), demand()
>         real matrix newton(), jacobian()
>         
> private:
>         void new()
> {c )-}

: 
: void Merger::new()
> {c -(}
>         m = Market(5) // 10 markets allowed by default
> {c )-}

: 
: void Merger::init()
> {c -(}
>         m[1].marketvar = marketvar
>         m[2].marketvar = marketvar
> {c )-}

: 
: void Merger::equilibrium(class Demand scalar D, string scalar touse, real sim)
> {c -(}
>         D.marketvar = marketvar // What is this?
>         real scalar i
>         real matrix it
>         real matrix iterations
>         real scalar convergence
>         D.init()
>         setperiods(touse)
>         iterations = J(periods, 1, 0)
>         for(i=1; i<= periods; i++ ) {c -(}
>                 period(i)
>                 D.get_data(periodvar)
>                 m[sim].get_data(periodvar)
>                 
>                 it = m[sim].equilibrium(D)
>                 
>                 iterations[i] = it[1]
>                 convergence = convergence & it[2]
>         {c )-}
>         st_numscalar("r(convergence)", convergence)
>         st_numscalar("r(iterations)", mean(iterations))
>         st_numscalar("r(maxiterations)", max(iterations))       
>         st_numscalar("r(maxit)", m[sim].param.maxit)
>         st_numscalar("r(markets)", periods)
>         st_numscalar("r(products)", rows(m[sim].p))
> {c )-}
{txt}note: variable convergence may be used before set

{com}: 
: void Merger::costestimate(class Demand scalar D, string scalar touse, real sim)
> {c -(}
>         D.marketvar = marketvar // What is this?
>         real scalar i
>         setperiods(touse)
>         D.init()
>         for(i=1; i<= periods; i++ ) {c -(}
>                 period(i)
>                 D.get_data(periodvar)
>                 m[sim].get_data(periodvar)
>                 m[sim].find_costs( D) 
>         {c )-}
> {c )-}

: 
: void Merger::demand(class Demand scalar D, string scalar touse, real sim)
> {c -(}
>         D.marketvar = marketvar // What is this?
>         real scalar i
>         real matrix s
>         real matrix p
>         setperiods(touse)
>         D.init()
>         for(i=1; i<= periods; i++ ) {c -(}
>                 period(i)
>                 D.get_data(periodvar)
>                 m[sim].get_data(periodvar)
>                 m[sim].get_demand(D)
>         {c )-}
> {c )-}
{txt}note: variable s unused
note: variable p unused

{com}: 
: void Merger::consumerSurplus(class Demand scalar D, string scalar touse, real sim)
> {c -(}
>         D.marketvar = marketvar // What is this?
>         real scalar i, cs1, cs2
>         real matrix s
>         real matrix p
>         setperiods(touse)
>         D.init()
>         for(i=1; i<= periods; i++ ) {c -(}
>                 period(i)
>                 D.get_data(periodvar)
>                 m[1].get_data(periodvar)
>                 m[sim].get_data(periodvar)
>                 cs1 = D.consumerSurplus(m[1].p) 
>                 cs2 = D.consumerSurplus(m[sim].p) 
>         {c )-}
>         st_numscalar("r(cs)", cs2 - cs1) // Returns last cs in last period. Average or matrix for multiple.
> {c )-}
{txt}note: variable s unused
note: variable p unused

{com}: 
: /********************************************************************************/
: // Market class
: 
: void Market::new()
> {c -(}
>         conduct = 0
>         firm = ""
>         ownershipmatrix = ""
> {c )-}

: 
: void Market::find_costs(class Demand D)
> {c -(}
>         real matrix nc
>         real matrix s
>         s = D.demand(q, p)
>         nc = p - lusolve( R :* D.share_jacobian( s , p) , -s )
> //      nc = p - cholsolve( -R :* D.share_jacobian( s , p) , s )
>         c[.] = nc
> {c )-}

: 
: real matrix Market::foc(class Demand D, real matrix P)
> {c -(}
>         real matrix S
>         S = D.shares( P )
>         return( ( R :* D.share_jacobian( S , P))*(P - c)+ S )
> {c )-}

: 
: real matrix Market::margins(class Demand D, real matrix P)
> {c -(}
>         real matrix S
>         S = D.shares( P )
>         return( cholsolve( (-R) :* (D.share_jacobian( S , P)) , S ) )
> {c )-}

: 
: void Market::get_demand(class Demand D)
> {c -(}
>         real matrix ns
>         ns = D.shares( p)
>         q[.] = D.quantity(ns, p)
> {c )-}

: 
: void Market::init()
> {c -(}
>         check_variable(firm, "firm")    
>         check_variable(price, "price")
>         check_variable(costs, "costs")
>         check_variable(initprice, "initprice")
>         check_variable(quantity, "quantity")
> {c )-}

: 
: void Market::get_data(string scalar touse)
> {c -(}
>         real matrix r
>         real matrix Rt, rs
>         st_view(q, ., quantity, touse)
>         st_view(p, ., price, touse)
>         st_view(p0, ., initprice, touse)
>         st_view(c, ., costs, touse)
>         
>         if(strlen(ownershipmatrix) == 0) {c -(}
>                 st_view(r, ., firm, touse)
>                 rs = groupindex(r)
> 
>                 Rt = group_matrix(rs)   
>                 R = editvalue(Rt'*Rt, 0, conduct)       
>         {c )-} else {c -(}
>                 R = st_matrix(ownershipmatrix)
>         {c )-}
> {c )-}
{txt}note: variable r may be used before set

{com}: 
: void Market::parameters()
> {c -(}
>         st_global("r(firm)", firm)
>         st_global("r(costs)", costs)
> {c )-}

: 
: /**************************************************************************************************/
: //                                     Functions to find equilibrium
: 
: real matrix Market::equilibrium(class Demand D)
> {c -(}       
>         real matrix it
>         if(param.method == 1) {c -(}
>                 it = fixed_point(D, param.maxit) 
>                 if( !it[2] & param.dampenIfNecessary ) {c -(}
>                         param.dampen = param.dampen / 2
>                         it = fixed_point(D, param.maxit) 
>                 {c )-}
>                 if( param.dampen == 1) {c -(}
>                         st_global("r(method)", "Fixed point")
>                 {c )-} else {c -(}
>                         st_global("r(method)", "Dampened Fixed point")
>                 {c )-}
>         {c )-} else if(param.method == 2) {c -(}
>                 it = fixed_point(D, 1)
>                 it = newton(D, param.maxit)
>                 st_global("r(method)", "Newton")
>         {c )-} else if(param.method == 3) {c -(}
>                 it = fixed_point(D, param.firstit)
>                 if( !it[2]) {c -(}
>                         it = newton(D, param.maxit)
>                 {c )-}
>                 st_global("r(method)", "Fixed point / Newton")
>         {c )-} else {c -(}
>                 display("Unknown method")
>                 _error(99)
>         {c )-} 
>         q[.] = D.quantity(s, p)
>         return(it)
> {c )-}

: 
: real Market::fixed_point(class Demand demand, real maxit)
> {c -(}       
>         real matrix P
>         real matrix S
>         real matrix Q
>         real matrix Pn
>         real matrix diff
>         real dist 
>         real i
>         real distance 
>         real convergence
>         
>         convergence = 1 
>         P = p0          
>         dist = param.sensitivity + 1
>         i = 0
>         diff = 0
>         while(i++ < maxit & dist > param.sensitivity)
>         {c -(}
>                 // for linear logit set Q=S, for CES logit set Q=S:/P xxx
>                 Pn = c + margins(demand, P)
>                 if(max(Pn) == .) {c -(}
>                         i = maxit + 1
>                         convergence = 0
>                         st_global("r(convergenceproblem)", "Could not invert the share Jacobian." )
>                         break
>                 {c )-}
>                 diff = Pn - P
>                 dist = cross(diff, diff)
>                 if( min(P) < 0 ) {c -(}
>                         convergence = 0
>                         st_global("r(convergenceproblem)", "Negative prices in price vector" )
>                         break
>                 {c )-}                       
>                 P = param.dampen*Pn + (1 - param.dampen)*P
>         {c )-}
>         if(i > maxit ) {c -(}
>                 st_global("r(convergenceproblem)", "Max number of iterations exceeded." )
>                 convergence = 0
>                 i--
>         {c )-}
>         S = demand.shares( P ) // This function should be called demand
>         diff = cross(S, S)
>         if(diff < param.sensitivity ) {c -(}
>                 st_global("r(convergenceproblem)", "Zero shares." )
>                 convergence = 0
>         {c )-}
>         if( min(P) < 0 | min(S) < 0  ) {c -(}
>                 st_global("r(convergenceproblem)", "Negative prices or shares." )
>                 convergence = 0
>         {c )-}
>         // st_numscalar("r(maxpricediff)", max(abs(diff)) )
>         p[.] = P[.]
>         s = S[.]
>         return((i,convergence))
> {c )-}
{txt}note: variable Q unused
note: variable distance unused

{com}: 
: real Market::newton(class Demand demand, real maxit)
> {c -(}       
>         real matrix P
>         real dist
>         real i
>         real matrix Pn
>         real l
>         real matrix diff
>         real matrix mat
>         real matrix S
>         real convergence
>         convergence = 1 
>         st_global("r(convergenceproblem)", "" )
>         
>         P = p0  
>         dist = 1 
>         i = 0
>         diff = 0
>         while(i++ < maxit & dist > param.sensitivity) // Should be dist > param.sensitivity*(1 + abs(xn) )
>         {c -(}
>                 mat =  jacobian(demand, P) 
>                 Pn = P - lusolve(mat, foc(demand, P) )
>                 if(max(Pn) == .) {c -(}
>                         i = maxit + 1
>                         convergence = 0
>                         st_global("r(convergenceproblem)", "The Newton method could not invert the Jacobian." )
>                         break
>                 {c )-}
>                 diff = Pn - P
>                 dist = cross(diff, diff)
>                 if( min(Pn) < 0 ) {c -(}
>                         l = -min(Pn :/ (Pn-P))
>                         P = l*Pn + (1-l)*P
>                         if( min(P) < 0 ) {c -(}
>                                 convergence = 0
>                                 st_global("r(convergenceproblem)", "Negative prices in price vector" )
>                                 break
>                         {c )-}                       
>                 {c )-} else {c -(}
>                         P = Pn
>                 {c )-}
>         {c )-}
>         if(i > maxit ) {c -(}
>                 st_global("r(convergenceproblem)", "Exceeded max number of iterations." )
>                 convergence = 0
>                 i--
>         {c )-}
>         st_numscalar("r(maxpricediff)", max(abs(diff)) )
>         diff = foc(demand, P)
>         st_numscalar("r(fixedpointdiff)", cross(diff, diff) )   
> 
>         S = demand.shares( P )
>         diff = cross(S, S)
>         if(diff < param.sensitivity ) {c -(}
>                 st_global("r(convergenceproblem)", "Zero shares." )
>                 convergence = 0
>         {c )-}
>         if( min(P) < 0 | min(S) < 0  ) {c -(}
>                 st_global("r(convergenceproblem)", "Negative prices or shares." )
>                 convergence = 0
>         {c )-}
>         
>         p[.] = P[.]
>         s = S[.]
>         return((i,convergence))
> {c )-}

: 
: real matrix Market::jacobian(class Demand D, real matrix x)
> {c -(}
>         real h
>         real scalar r
>         real scalar i
>         real matrix result
>         real matrix ep
>         r = rows(x)
>         ep = J(r,1, param.h_epsilon)
>         h = diag(rowmax( (ep, abs(x) :* param.h_epsilon) ) ) 
>         result = J(r, r, 0)
>         for(i=1; i<= r; i++ ) {c -(}
>                 result[.,i] = (foc(D, x + h[.,i]) - foc(D, x)):/h[i,i]
>         {c )-}
>         return( result )
> {c )-}

: 
: /********************************************************************************/
: // Variable class
: 
: void VariableClass::setperiods(string scalar touse)
> {c -(}
>         real matrix t
>         real matrix sample
>         string scalar indexvar
>         real scalar i
>         real scalar tprev
>         
>         indexvar = st_tempname()
>         periodvar = st_tempname() // Note that periodvar is a Merger global.
>         (void) st_addvar("int", (indexvar), 0)
>         (void) st_addvar("int", (periodvar), 0) 
>         st_view(index, ., (indexvar)) // index class variable
>         st_view(period, ., (periodvar)) // index class variable, opened but not used here
>         if(marketvar != "" ) {c -(} // marketvar class variable  
>                 stata("sort "+marketvar ) // Sort is needed to do per period.
>         {c )-} 
>         st_view(t, ., (marketvar))
>         if( length(touse) ) {c -(}
>                 st_view(sample, ., (touse))
>         {c )-} else {c -(}
>                 sample = st_addvar("int", st_tempname(), 1)
>         {c )-}
>         real scalar j
>         j=0
>         tprev =.
>         for(i=1; i<= rows(index); i++ ) {c -(}
>                 if(sample[i] & t[i] != tprev) {c -(}
>                         tprev = t[i]
>                         j++
>                 {c )-}
>                 index[i] = sample[i] * j
>         {c )-}
>         periods = j
> {c )-}
{txt}note: variable t may be used before set
note: variable sample may be used before set

{com}: 
: void VariableClass::period(real scalar current)
> {c -(}
>         real matrix x
>         x = (index :== current)
>         period[.] = x[.]
> {c )-}

: 
: void VariableClass::getvariable(real matrix m, string scalar name, string scalar touse)
> {c -(}
>         st_view(m, ., tokens(name), touse)
>         assert(m != .)
> {c )-}

: 
: void VariableClass::createvariable(string scalar name)
> {c -(}
>         string varname
>         varname = tokens(name)
>         if( _st_varindex(varname) == . ) {c -(}
>                 (void) st_addvar("double", (varname))
>         {c )-}
> {c )-}

: 
: void VariableClass::check_variable(string scalar variable, string scalar varname)
> {c -(}
>         if(variable == .) {c -(}
>                 display("ERROR: Variable "+varname+" is missing")
>                 assert(0)
>         {c )-}
>         if(!length(variable)) {c -(}
>                 display("ERROR: Variable "+varname+" has not been set")
>                 assert(0)
>         {c )-}
>         if(_st_varindex(variable) == .) {c -(}
>                 display("ERROR: Variable "+varname+" does not exist:"+variable)
>                 assert(0)
>         {c )-}
> {c )-}

: 
: // Transform column vector with group id to matrix with 1 if is in group column
: real matrix VariableClass::group_matrix(real matrix A)
> {c -(}
>         real matrix B
>         real i
>         B = J(rows(A),max(A), 0)
>         for(i=1; i<=rows(A); i++) {c -(}
>                 B[i,A[i]] = 1
>         {c )-}
>         return(B')
> {c )-}

: 
: // renumber column vector consecutively
: real matrix VariableClass::groupindex(real matrix q) 
> {c -(}
>         real matrix p, r, newindex
>         real matrix prev, inr, sortorder
>         real scalar i, j, isnew
>         sortorder = J(1, cols(q), .)
>         for(i=1; i<=cols(q); i++) {c -(}
>                 sortorder[i] = i
>         {c )-}
>         p = order(q, sortorder )
>         r = q[p,.]
>         newindex = J(rows(r), cols(r), .)
>         prev = J(1, cols(r), .)
>         inr = J(1, cols(r), 0)
>         for(i=1; i<=rows(r); i++) {c -(}
>                 isnew = 0
>                 for(j=1; j<=cols(r); j++) {c -(}
>                         if(isnew | r[i,j] != prev[j]) {c -(}
>                                 prev[j] = r[i,j]
>                                 inr[j] = inr[j] + 1
>                                 isnew = 1
>                         {c )-} 
>                         newindex[i,j] = inr[j]
>                 {c )-}
>         {c )-}
>         return(newindex[invorder(p),.])
> {c )-}

: 
: void SolverParam::new()
> {c -(}
>         init()
> {c )-}

: 
: void SolverParam::init()
> {c -(}
>         method = 2
>         maxit = 1000
>         sensitivity = 10^-8
>         prediction = 0
>         firstit = 1 
>         dampen = 1
>         dampenIfNecessary = 1
>         h_epsilon = 10^-6 
> {c )-}

: 
: end
{txt}{hline}

{com}. 
{txt}end of do-file
{p 0 4 2}
(file c:\ado\personal\lmergersim.mlib created)
{p_end}
(9 functions added)

{com}. 
. use test 
{txt}
{com}. 
. // ********************* TEST 8 ***********************
. // SIMPLE LOGIT
. if 1 {c -(}
. 
.         // two ways
.         // specify one-level nest, but set sigma=0
. mergersim init, nests(segment) unit price(princ) quantity(qu) marketsize(MSIZE) firm(firm) alpha(-4) sigmas(0) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Unit demand one-level nested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}princ{col 59}M_lsjg
{hline 80}
{txt}Variables generated: {res}M_ls M_lsjg
{hline 80}
{com}. mergersim market if year == 1998 & country == 3
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Unit demand one-level nested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-4.000
{txt}sigma1 = {res}0.000 
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -2.602     1.129    -7.621    -1.144
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.004     0.007     0.000     0.038
{txt}{ralign 12:M_ejl} {...}
{c |}{...}
 {res}    0.004     0.007     0.000     0.038
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}              princ      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}              {res}0.748               0.495               0.379
              {txt}Toyota {c |}              {res}0.403               0.153               0.663
                {txt}Fiat {c |}              {res}0.639               0.387               0.450
                {txt}Ford {c |}              {res}0.546               0.292               0.508
               {txt}Honda {c |}              {res}0.657               0.407               0.398
             {txt}Hyundai {c |}              {res}0.538               0.288               0.511
                 {txt}Kia {c |}              {res}0.470               0.220               0.574
               {txt}Mazda {c |}              {res}0.593               0.342               0.451
            {txt}Mercedes {c |}              {res}0.998               0.744               0.273
          {txt}Mitsubishi {c |}              {res}0.660               0.409               0.400
              {txt}Nissan {c |}              {res}0.629               0.378               0.438
       {txt}GeneralMotors {c |}              {res}0.830               0.574               0.362
             {txt}Peugeot {c |}              {res}0.683               0.432               0.420
             {txt}Renault {c |}              {res}0.637               0.385               0.462
              {txt}Suzuki {c |}              {res}0.384               0.134               0.668
              {txt}Toyota {c |}              {res}0.682               0.431               0.414
                  {txt}VW {c |}              {res}0.716               0.454               0.451
               {txt}Volvo {c |}              {res}0.923               0.672               0.278
              {txt}Daewoo {c |}              {res}0.562               0.312               0.504
             {txt}Daimler {c |}              {res}0.360               0.110               0.695
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. matrix elas = r(elasticities)
. local ejj = el(elas,1,1)
. local ejk = el(elas,2,1)
. di `ejj'
{res}-2.6021866
{com}. di `ejk'
{res}.00424791
{com}. mergersim init, nests(segment) unit price(princ) quantity(qu) marketsize(MSIZE) firm(firm) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Unit demand one-level nested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}princ{col 59}M_lsjg
{hline 80}
{txt}Variables generated: {res}M_ls M_lsjg
{hline 80}
{com}. mergersim market if year == 1998 & country == 3, elasticities(`ejj' `ejk' )
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Unit demand one-level nested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-3.780
{txt}sigma1 = {res}0.055 
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -2.594     1.122    -7.612    -1.144
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.013     0.024     0.000     0.119
{txt}{ralign 12:M_ejl} {...}
{c |}{...}
 {res}    0.004     0.007     0.000     0.036
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}              princ      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}              {res}0.748               0.492               0.383
              {txt}Toyota {c |}              {res}0.403               0.153               0.663
                {txt}Fiat {c |}              {res}0.639               0.387               0.452
                {txt}Ford {c |}              {res}0.546               0.290               0.512
               {txt}Honda {c |}              {res}0.657               0.407               0.398
             {txt}Hyundai {c |}              {res}0.538               0.288               0.511
                 {txt}Kia {c |}              {res}0.470               0.220               0.574
               {txt}Mazda {c |}              {res}0.593               0.342               0.452
            {txt}Mercedes {c |}              {res}0.998               0.737               0.279
          {txt}Mitsubishi {c |}              {res}0.660               0.409               0.401
              {txt}Nissan {c |}              {res}0.629               0.378               0.439
       {txt}GeneralMotors {c |}              {res}0.830               0.572               0.365
             {txt}Peugeot {c |}              {res}0.683               0.431               0.421
             {txt}Renault {c |}              {res}0.637               0.384               0.464
              {txt}Suzuki {c |}              {res}0.384               0.134               0.669
              {txt}Toyota {c |}              {res}0.682               0.431               0.415
                  {txt}VW {c |}              {res}0.716               0.450               0.458
               {txt}Volvo {c |}              {res}0.923               0.672               0.279
              {txt}Daewoo {c |}              {res}0.562               0.312               0.504
             {txt}Daimler {c |}              {res}0.360               0.110               0.695
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. {c )-}
{txt}
{com}. if 1 {c -(}
. 
. // ********************* TEST 8b ***********************
. 
.         // do not specify nest
. mergersim init, unit price(princ) quantity(qu) marketsize(MSIZE) firm(firm) alpha(-4) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Unit demand unnested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}princ{col 59}
{hline 80}
{txt}Variables generated: {res}M_ls
{hline 80}
{com}. mergersim market if year == 1998 & country == 3
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Unit demand unnested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-4.000
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -2.602     1.129    -7.621    -1.144
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.004     0.007     0.000     0.038
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}              princ      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}              {res}0.748               0.495               0.379
              {txt}Toyota {c |}              {res}0.403               0.153               0.663
                {txt}Fiat {c |}              {res}0.639               0.387               0.450
                {txt}Ford {c |}              {res}0.546               0.292               0.508
               {txt}Honda {c |}              {res}0.657               0.407               0.398
             {txt}Hyundai {c |}              {res}0.538               0.288               0.511
                 {txt}Kia {c |}              {res}0.470               0.220               0.574
               {txt}Mazda {c |}              {res}0.593               0.342               0.451
            {txt}Mercedes {c |}              {res}0.998               0.744               0.273
          {txt}Mitsubishi {c |}              {res}0.660               0.409               0.400
              {txt}Nissan {c |}              {res}0.629               0.378               0.438
       {txt}GeneralMotors {c |}              {res}0.830               0.574               0.362
             {txt}Peugeot {c |}              {res}0.683               0.432               0.420
             {txt}Renault {c |}              {res}0.637               0.385               0.462
              {txt}Suzuki {c |}              {res}0.384               0.134               0.668
              {txt}Toyota {c |}              {res}0.682               0.431               0.414
                  {txt}VW {c |}              {res}0.716               0.454               0.451
               {txt}Volvo {c |}              {res}0.923               0.672               0.278
              {txt}Daewoo {c |}              {res}0.562               0.312               0.504
             {txt}Daimler {c |}              {res}0.360               0.110               0.695
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. matrix elas = r(elasticities)
. local ejj = el(elas,1,1)
. di `ejj'
{res}-2.6021866
{com}. mergersim init, unit price(princ) quantity(qu) marketsize(MSIZE) firm(firm) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Unit demand unnested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}princ{col 59}
{hline 80}
{txt}Variables generated: {res}M_ls
{hline 80}
{com}. mergersim market if year == 1998 & country == 3, elasticities(`ejj' )
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Unit demand unnested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-4.000
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -2.602     1.129    -7.621    -1.144
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.004     0.007     0.000     0.038
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}              princ      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}              {res}0.748               0.495               0.379
              {txt}Toyota {c |}              {res}0.403               0.153               0.663
                {txt}Fiat {c |}              {res}0.639               0.387               0.450
                {txt}Ford {c |}              {res}0.546               0.292               0.508
               {txt}Honda {c |}              {res}0.657               0.407               0.398
             {txt}Hyundai {c |}              {res}0.538               0.288               0.511
                 {txt}Kia {c |}              {res}0.470               0.220               0.574
               {txt}Mazda {c |}              {res}0.593               0.342               0.451
            {txt}Mercedes {c |}              {res}0.998               0.744               0.273
          {txt}Mitsubishi {c |}              {res}0.660               0.409               0.400
              {txt}Nissan {c |}              {res}0.629               0.378               0.438
       {txt}GeneralMotors {c |}              {res}0.830               0.574               0.362
             {txt}Peugeot {c |}              {res}0.683               0.432               0.420
             {txt}Renault {c |}              {res}0.637               0.385               0.462
              {txt}Suzuki {c |}              {res}0.384               0.134               0.668
              {txt}Toyota {c |}              {res}0.682               0.431               0.414
                  {txt}VW {c |}              {res}0.716               0.454               0.451
               {txt}Volvo {c |}              {res}0.923               0.672               0.278
              {txt}Daewoo {c |}              {res}0.562               0.312               0.504
             {txt}Daimler {c |}              {res}0.360               0.110               0.695
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. {c )-}
{txt}
{com}. 
. if 1 {c -(}
. // ********************* TEST 9 ***********************
.         // to illustrate: specify alpha and sigmas as rounded values of the previous estimates
. mergersim init, nests(segment domestic) unit price(princ) quantity(qu) marketsize(MSIZE) firm(firm) alpha(-1.2) sigmas (0.9 0.6) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Unit demand two-level nested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}princ{col 59}M_lsjh M_lshg
{hline 80}
{txt}Variables generated: {res}M_ls M_lsjh M_lshg
{hline 80}
{com}. mergersim market if year == 1998 & country == 3
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Unit demand two-level nested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-1.200
{txt}sigma1 = {res}0.900 
{txt}sigma2 = {res}0.600 
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -7.041     2.931   -22.417    -3.396
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.779     1.140     0.007     4.819
{txt}{ralign 12:M_ejl} {...}
{c |}{...}
 {res}    0.073     0.149     0.001     0.775
{txt}{ralign 12:M_ejm} {...}
{c |}{...}
 {res}    0.001     0.002     0.000     0.011
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}              princ      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}              {res}0.748               0.644               0.150
              {txt}Toyota {c |}              {res}0.403               0.318               0.225
                {txt}Fiat {c |}              {res}0.639               0.541               0.177
                {txt}Ford {c |}              {res}0.546               0.439               0.221
               {txt}Honda {c |}              {res}0.657               0.565               0.146
             {txt}Hyundai {c |}              {res}0.538               0.453               0.173
                 {txt}Kia {c |}              {res}0.470               0.386               0.193
               {txt}Mazda {c |}              {res}0.593               0.503               0.160
            {txt}Mercedes {c |}              {res}0.998               0.810               0.183
          {txt}Mitsubishi {c |}              {res}0.660               0.569               0.145
              {txt}Nissan {c |}              {res}0.629               0.534               0.162
       {txt}GeneralMotors {c |}              {res}0.830               0.723               0.154
             {txt}Peugeot {c |}              {res}0.683               0.592               0.153
             {txt}Renault {c |}              {res}0.637               0.541               0.182
              {txt}Suzuki {c |}              {res}0.384               0.299               0.228
              {txt}Toyota {c |}              {res}0.682               0.594               0.146
                  {txt}VW {c |}              {res}0.716               0.599               0.197
               {txt}Volvo {c |}              {res}0.923               0.821               0.111
              {txt}Daewoo {c |}              {res}0.562               0.477               0.171
             {txt}Daimler {c |}              {res}0.360               0.276               0.235
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. matrix elas = r(elasticities)
. local ejj = el(elas,1,1)
. local ejk = el(elas,2,1)
. local ejl = el(elas,3,1)
. di `ejj'
{res}-7.0406028
{com}. di `ejk'
{res}.77870072
{com}. di `ejl'
{res}.07278104
{com}. mergersim init, nests(segment domestic) unit price(princ) quantity(qu) marketsize(MSIZE) firm(firm) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Unit demand two-level nested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}princ{col 59}M_lsjh M_lshg
{hline 80}
{txt}Variables generated: {res}M_ls M_lsjh M_lshg
{hline 80}
{com}. mergersim market if year == 1998 & country == 3, elasticities(`ejj' `ejk' `ejl')
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Unit demand two-level nested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-1.035
{txt}sigma1 = {res}0.914 
{txt}sigma2 = {res}0.655 
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -7.034     2.929   -22.411    -3.396
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.785     1.151     0.007     4.821
{txt}{ralign 12:M_ejl} {...}
{c |}{...}
 {res}    0.079     0.163     0.001     0.844
{txt}{ralign 12:M_ejm} {...}
{c |}{...}
 {res}    0.001     0.002     0.000     0.010
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}              princ      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}              {res}0.748               0.644               0.150
              {txt}Toyota {c |}              {res}0.403               0.318               0.225
                {txt}Fiat {c |}              {res}0.639               0.541               0.177
                {txt}Ford {c |}              {res}0.546               0.438               0.221
               {txt}Honda {c |}              {res}0.657               0.565               0.146
             {txt}Hyundai {c |}              {res}0.538               0.453               0.173
                 {txt}Kia {c |}              {res}0.470               0.386               0.193
               {txt}Mazda {c |}              {res}0.593               0.503               0.160
            {txt}Mercedes {c |}              {res}0.998               0.805               0.187
          {txt}Mitsubishi {c |}              {res}0.660               0.569               0.145
              {txt}Nissan {c |}              {res}0.629               0.534               0.162
       {txt}GeneralMotors {c |}              {res}0.830               0.722               0.154
             {txt}Peugeot {c |}              {res}0.683               0.592               0.153
             {txt}Renault {c |}              {res}0.637               0.541               0.182
              {txt}Suzuki {c |}              {res}0.384               0.299               0.228
              {txt}Toyota {c |}              {res}0.682               0.594               0.146
                  {txt}VW {c |}              {res}0.716               0.598               0.198
               {txt}Volvo {c |}              {res}0.923               0.821               0.111
              {txt}Daewoo {c |}              {res}0.562               0.477               0.171
             {txt}Daimler {c |}              {res}0.360               0.275               0.235
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. 
. {c )-}
{txt}
{com}. if 1 {c -(}
. 
. // ********************* TEST 10 ***********************
.         // no efficiencies
. mergersim init, nests(segment domestic) ces price(pr) quantity(qu) marketsize(MSIZE1) firm(firm) alpha(-0.5) sigmas(0.9 .6) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Constant expenditure two-level nested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}M_lp{col 59}M_lsjh M_lshg
{hline 80}
{txt}Variables generated: {res}M_ls M_lp M_lsjh M_lshg
{hline 80}
{com}. mergersim market if year == 1998 & country == 3
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Constant expenditure two-level nested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-0.500
{txt}sigma1 = {res}0.900 
{txt}sigma2 = {res}0.600 
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -5.574     0.493    -5.995    -4.054
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.426     0.493     0.005     1.946
{txt}{ralign 12:M_ejl} {...}
{c |}{...}
 {res}    0.039     0.065     0.000     0.283
{txt}{ralign 12:M_ejm} {...}
{c |}{...}
 {res}    0.001     0.001     0.000     0.006
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}                 pr      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}          {res}34231.668           27419.879               0.194
              {txt}Toyota {c |}          {res}18437.500           15337.082               0.168
                {txt}Fiat {c |}          {res}29257.455           23750.927               0.189
                {txt}Ford {c |}          {res}24975.000           20033.644               0.202
               {txt}Honda {c |}          {res}30097.500           24680.508               0.180
             {txt}Hyundai {c |}          {res}24630.000           20471.297               0.169
                 {txt}Kia {c |}          {res}21509.000           17900.492               0.168
               {txt}Mazda {c |}          {res}27142.000           22288.345               0.177
            {txt}Mercedes {c |}          {res}45665.332           31621.803               0.290
          {txt}Mitsubishi {c |}          {res}30200.250           24756.190               0.180
              {txt}Nissan {c |}          {res}28805.000           23426.182               0.183
       {txt}GeneralMotors {c |}          {res}38000.000           30107.953               0.206
             {txt}Peugeot {c |}          {res}31277.500           25700.746               0.179
             {txt}Renault {c |}          {res}29170.000           23851.598               0.188
              {txt}Suzuki {c |}          {res}17596.666           14613.672               0.170
              {txt}Toyota {c |}          {res}31230.000           25777.323               0.175
                  {txt}VW {c |}          {res}32774.922           25550.836               0.221
               {txt}Volvo {c |}          {res}42250.000           33584.989               0.201
              {txt}Daewoo {c |}          {res}25720.000           21366.422               0.169
             {txt}Daimler {c |}          {res}16480.000           13705.549               0.168
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. matrix elas = r(elasticities)
. local ejj = el(elas,1,1)
. local ejk = el(elas,2,1)
. local ejl = el(elas,3,1)
. di `ejj'
{res}-5.5740785
{com}. di `ejk'
{res}.42592147
{com}. di `ejl'
{res}.03932353
{com}. mergersim init, nests(segment domestic) ces price(pr) quantity(qu) marketsize(MSIZE1) firm(firm) clear
{res}{hline 80}
{hi:MERGERSIM: Merger Simulation Program}
Version 2.0, Revision: 224 
{hline 80}
Constant expenditure two-level nested logit

{col 1}{col 19}{txt}Depvar{col 39}Price{col 59}Group shares
{col 19}{hline 62}
{col 1}{col 19}{res}M_ls{col 39}M_lp{col 59}M_lsjh M_lshg
{hline 80}
{txt}Variables generated: {res}M_ls M_lp M_lsjh M_lshg
{hline 80}
{com}. mergersim market if year == 1998 & country == 3, elasticities(`ejj' `ejk' `ejl')
{res}{hline 81}
{txt}Supply: {res}Bertrand competition
{txt}Demand: {res}Constant expenditure two-level nested logit
{hline 80}
Demand calibration

Parameters

{txt}alpha = {res}-0.434
{txt}sigma1 = {res}0.913 
{txt}sigma2 = {res}0.653 
{hline 64}
Own- and Cross-Price Elasticities:  unweighted market averages

{txt}{ralign 12:variable} {...}
{c |}      mean        sd       min       max
{hline 13}{c +}{hline 40}
{ralign 12:M_ejj} {...}
{c |}{...}
 {res}   -5.571     0.498    -5.995    -4.030
{txt}{ralign 12:M_ejk} {...}
{c |}{...}
 {res}    0.429     0.498     0.005     1.970
{txt}{ralign 12:M_ejl} {...}
{c |}{...}
 {res}    0.043     0.070     0.000     0.307
{txt}{ralign 12:M_ejm} {...}
{c |}{...}
 {res}    0.001     0.001     0.000     0.005
{txt}{hline 13}{c BT}{hline 40}
Observations: {res}97
{hline 64}

Pre-merger Market Conditions 
{txt}Unweighted averages by firm

{hline 21}{c TT}{hline 59}
           firm code {c |}                 pr      Marginal costs   Pre-merger Lerner
{hline 21}{c +}{hline 59}
                 BMW {c |}          {res}34231.668           27396.505               0.194
              {txt}Toyota {c |}          {res}18437.500           15336.889               0.168
                {txt}Fiat {c |}          {res}29257.455           23748.030               0.189
                {txt}Ford {c |}          {res}24975.000           20025.308               0.203
               {txt}Honda {c |}          {res}30097.500           24679.189               0.180
             {txt}Hyundai {c |}          {res}24630.000           20471.021               0.169
                 {txt}Kia {c |}          {res}21509.000           17900.377               0.168
               {txt}Mazda {c |}          {res}27142.000           22286.538               0.177
            {txt}Mercedes {c |}          {res}45665.332           31436.614               0.294
          {txt}Mitsubishi {c |}          {res}30200.250           24753.815               0.180
              {txt}Nissan {c |}          {res}28805.000           23425.017               0.183
       {txt}GeneralMotors {c |}          {res}38000.000           30096.706               0.207
             {txt}Peugeot {c |}          {res}31277.500           25698.940               0.179
             {txt}Renault {c |}          {res}29170.000           23848.532               0.188
              {txt}Suzuki {c |}          {res}17596.666           14613.340               0.170
              {txt}Toyota {c |}          {res}31230.000           25776.245               0.175
                  {txt}VW {c |}          {res}32774.922           25517.320               0.222
               {txt}Volvo {c |}          {res}42250.000           33578.792               0.202
              {txt}Daewoo {c |}          {res}25720.000           21366.177               0.169
             {txt}Daimler {c |}          {res}16480.000           13705.311               0.168
{txt}{hline 21}{c BT}{hline 59}
{res}{txt}Variables generated: {res}M_costs M_delta 
{hline 81}
{com}. 
. {c )-}
{txt}
{com}. 
{txt}end of do-file

{com}. log close
      {txt}name:  {res}<unnamed>
       {txt}log:  {res}C:\Users\n13017\Documents\Programming\mergersim\trunk\calibrated_elasticities.smcl
  {txt}log type:  {res}smcl
 {txt}closed on:  {res}15 Sep 2014, 16:44:09
{txt}{.-}
{smcl}
{txt}{sf}{ul off}